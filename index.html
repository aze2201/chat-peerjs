<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>üì± GroupChat ¬∑ DOC + SCREEN ¬∑ mobile WhatsApp style</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        /* ---------- üé® WhatsApp/Telegram inspired, big & finger-friendly ---------- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #0b1c26; background: radial-gradient(circle at 20% 30%, #1e3a4e, #0e1e26);
            min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 8px;
        }
        .app {
            max-width: 1100px; width: 100%; background: #0e1e26; backdrop-filter: blur(30px);
            border-radius: 32px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); padding: 20px 16px;
            border: 1px solid rgba(80,140,180,0.3);
        }
        /* header / top */
        .header { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; margin-bottom: 16px; }
        h1 { font-size: 1.9rem; font-weight: 700; color: #e6f7ff; letter-spacing: -0.5px; display: flex; align-items: center; gap: 6px; text-shadow: 0 2px 5px #00000020; }
        .ice-badge { background: #1f5e80; color: white; padding: 6px 18px; border-radius: 40px; font-size: 0.8rem; font-weight: 600; border: 1px solid #7ab3c9; }

        /* ---------- username ‚Äì always visible, larger ---------- */
        .username-panel {
            background: #142e3a; border-radius: 60px; padding: 12px 20px; margin-bottom: 20px;
            display: flex; flex-wrap: wrap; align-items: center; gap: 12px; border: 1px solid #2e6b7c;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.2);
        }
        .username-panel label { font-weight: 700; color: #cae9ff; font-size: 1.1rem; letter-spacing: 0.5px; }
        #usernameInput {
            flex: 1; min-width: 200px; padding: 14px 22px; border: none; border-radius: 50px;
            font-size: 1.1rem; background: #1d3e4c; color: white; outline: none; transition: 0.2s;
            border: 1.5px solid transparent;
        }
        #usernameInput:focus { border-color: #4ab0d0; background: #15323d; }
        #usernameInput::placeholder { color: #a0c6d0; }

        /* ---------- pre‚Äëchat (room generate) ---------- */
        .section { background: #112e38cc; backdrop-filter: blur(8px); border-radius: 36px; padding: 24px 20px; margin-bottom: 20px; border: 1px solid #3c798b; }
        .flex-row { display: flex; flex-wrap: wrap; align-items: center; gap: 16px; }
        .btn {
            background: #256579; border: none; color: white; padding: 14px 28px; border-radius: 60px;
            font-weight: 700; font-size: 1.1rem; display: inline-flex; align-items: center; justify-content: center;
            gap: 10px; cursor: pointer; transition: 0.2s; border: 1px solid #80d0e0; box-shadow: 0 8px 16px #00000040;
            flex: 0 0 auto; letter-spacing: 0.5px;
        }
        .btn:hover { background: #34879c; transform: scale(0.97); }
        .btn:disabled { opacity: 0.4; pointer-events: none; }
        .btn-outline { background: transparent; border: 2px solid #5ac8e0; color: #e2f0ff; box-shadow: none; }

        .link-box { background: #0d303b; padding: 16px 22px; border-radius: 60px; word-break: break-all; font-size: 1rem; border: 1px solid #4f9db2; display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; margin-top: 16px; color: #dbf2ff; }
        #customSessionId { flex:1; padding: 16px 24px; border-radius: 60px; border: none; background: #1b4957; color: white; font-size: 1.1rem; border: 1px solid #30809b; }
        #customSessionId::placeholder { color: #addee9; }

        /* ---------- CHAT interface ‚Äì big bubbles, comfortable ---------- */
        .chat-container {
            background: #0a232b; border-radius: 36px; padding: 20px; margin-top: 8px;
            border: 1px solid #2d7488; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
        }
        .messages {
            background: #0b1c22; border-radius: 28px; padding: 22px 16px; height: 360px;
            overflow-y: auto; display: flex; flex-direction: column; gap: 14px; margin-bottom: 18px;
            border: 1px solid #275f6b; box-shadow: inset 0 6px 12px #00000030;
        }
        /* ‚Äî‚Äî‚Äî‚Äî‚Äî message bubbles ‚Äî‚Äî‚Äî‚Äî‚Äî */
        .message {
            background: #1e424b; padding: 14px 20px; border-radius: 24px 24px 24px 8px;
            max-width: 85%; word-break: break-word; align-self: flex-start;
            border: 1px solid #4895a8; color: #f0fafc; font-size: 1.05rem; line-height: 1.45;
            box-shadow: 0 2px 6px #00000030;
        }
        .message.self {
            background: #1f5d6b; color: white; align-self: flex-end; border-radius: 24px 24px 8px 24px;
            border: 1px solid #83d1e0;
        }
        .message.system {
            background: transparent; color: #b7e1ed; align-self: center; font-size: 0.95rem;
            border: 1px dashed #519faf; max-width: 98%; backdrop-filter: blur(4px);
        }
        /* file attachments ‚Äì nice card */
        .file-attachment {
            background: #0f313a; border-radius: 18px; padding: 12px 16px; margin-top: 8px;
            display: flex; align-items: center; gap: 14px; border: 1px solid #5ba9b9;
        }
        .file-icon { font-size: 2.2rem; }
        .file-info { display: flex; flex-direction: column; }
        .file-name { font-weight: 700; color: #daf0ff; font-size: 1rem; }
        .file-size { color: #aad3df; font-size: 0.85rem; }
        .download-link { background: #1d6b7c; padding: 8px 18px; border-radius: 40px; color: white; text-decoration: none; font-weight: 600; margin-left: auto; }
        .message img { max-width: 200px; max-height: 200px; border-radius: 20px; display: block; margin-top: 8px; border: 2px solid #519faf; }

        /* ‚Äî‚Äî‚Äî‚Äî‚Äî input row ‚Äì sticky, big ‚Äî‚Äî‚Äî‚Äî‚Äî */
        .input-row {
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px; background: #0b2c35;
            padding: 12px 18px; border-radius: 80px; border: 1px solid #328296;
        }
        #messageInput {
            flex: 1; min-width: 200px; padding: 16px 22px; border: none; border-radius: 60px;
            font-size: 1.1rem; background: #163f49; color: white; outline: none;
            border: 1.5px solid transparent; transition: 0.2s;
        }
        #messageInput:focus { border-color: #71d0e3; background: #10333b; }
        #messageInput::placeholder { color: #b8e5ee; }

        .file-label, .screen-share-btn {
            background: #1b5768; padding: 14px 20px; border-radius: 50px; font-size: 1.5rem;
            border: 1px solid #86d6e6; cursor: pointer; color: white; display: inline-flex;
            align-items: center; gap: 8px; transition: 0.2s; box-shadow: 0 4px 8px #00000040;
        }
        .file-label:hover, .screen-share-btn:hover { background: #2c7e91; }
        #sendBtn { background: #136b7c; padding: 16px 28px; font-size: 1.2rem; }

        /* ‚Äî‚Äî‚Äî‚Äî‚Äî screen share preview ‚Äî‚Äî‚Äî‚Äî‚Äî */
        .screen-video-container {
            background: #001116; border-radius: 28px; padding: 16px; margin-bottom: 16px;
            border: 2px solid #00c8ff; display: none; flex-wrap: wrap; align-items: center; gap: 16px;
        }
        .screen-video-container video { width: 100%; max-height: 260px; border-radius: 24px; border: 2px solid #3fa5b5; background: black; }
        .stop-share-btn { background: #c24343; padding: 12px 24px; border-radius: 50px; font-weight: bold; border: none; color: white; font-size: 1rem; }

        /* ‚Äî‚Äî‚Äî‚Äî‚Äî status bar ‚Äî‚Äî‚Äî‚Äî‚Äî */
        .status-bar { display: flex; flex-wrap: wrap; justify-content: space-between; margin-top: 16px; font-size: 0.9rem; color: #d2f0fc; background: #0b2a33; padding: 12px 22px; border-radius: 60px; border: 1px solid #3f94a3; }
        .dot { width: 12px; height: 12px; border-radius: 50%; background: #708e96; display: inline-block; margin-right: 8px; }
        .dot.active { background: #3ae03a; box-shadow: 0 0 18px #26e626; }
        .peer-count { background: #1f5766; color: white; padding: 6px 20px; border-radius: 50px; font-size: 0.9rem; }

        .hidden { display: none !important; }
        #roomLinkDisplay { font-size: 0.85rem; background: #13333d; padding: 8px 18px; border-radius: 50px; color: #d0ecf5; }

        @media (max-width: 600px) {
            .app { padding: 16px 12px; } h1 { font-size: 1.7rem; }
            .message { font-size: 1.1rem; padding: 16px 22px; }
            .btn, .file-label, .screen-share-btn { padding: 14px 22px; }
        }
    </style>
</head>
<body>
    <div class="app" id="app">

        <!-- header -->
        <div class="header">
            <h1>üí¨ Share<span style="color:#b3ecff;">Chat</span> <span style="font-size:0.9rem; background:#1f6270; padding:6px 18px; border-radius:40px;">DOC+SCREEN</span></h1>
            <span class="ice-badge">üì± mobile TURN</span>
        </div>

        <!-- GLOBAL USERNAME (big) -->
        <div class="username-panel">
            <label>üë§ Name</label>
            <input type="text" id="usernameInput" placeholder="Your nickname" value="Guest" autocomplete="off">
        </div>

        <!-- ========== PRE‚ÄëCHAT: SESSION (only if no session in URL) ========= -->
        <div id="preChatSection">
            <div id="generatorView" class="section">
                <div style="margin-bottom: 16px; font-weight: 700; color: #c3ecff; font-size:1.2rem;">üöÄ New room</div>
                <div class="flex-row">
                    <input type="text" id="customSessionId" placeholder="room name (optional)">
                    <button id="generateBtn" class="btn">üîó Generate link</button>
                </div>
                <div id="linkOutput" style="display: none;" class="link-box">
                    <span id="shareableLink" style="font-weight: 500;"></span>
                    <button id="copyLinkBtn" style="background: transparent; border: none; font-size: 1.8rem; cursor: pointer; color:white;">üìã</button>
                </div>
                <div style="margin-top: 24px;">
                    <button id="hostChatBtn" class="btn" style="background: #1c7c8c; padding: 16px 36px;">üé§ Host this room</button>
                    <span style="margin-left: 12px; color: #b0e4f0; font-size:1rem;">(you become hub)</span>
                </div>
            </div>
        </div>

        <!-- ========== CHAT INTERFACE ========== -->
        <div id="chatInterface" class="hidden">
            <!-- room link -->
            <div id="sessionLinkContainer" style="background: #0d3640; border-radius: 60px; padding: 14px 22px; margin-bottom: 20px; display: flex; flex-wrap: wrap; align-items: center; gap: 10px;">
                <span style="font-weight: 700; color:#c5f0ff;">üîó room:</span>
                <span id="roomLinkDisplay" style="word-break: break-all;"></span>
                <button id="copyRoomLinkBtn" style="background: #1f6575; border: none; padding: 8px 22px; border-radius: 50px; color:white; font-weight:600;">üìã copy</button>
            </div>

            <!-- chat area -->
            <div class="chat-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <span id="roomNameBadge" style="background: #1e4f5c; padding: 8px 24px; border-radius: 60px; font-size:0.95rem; color:#ecfeff;">üìå <span id="currentSessionSpan">-</span></span>
                    <span id="connectionStatus" class="peer-count">‚öôÔ∏è connecting</span>
                </div>

                <!-- üñ•Ô∏è SCREEN SHARE VIDEO CONTAINER (visible only when sharing) -->
                <div id="screenVideoContainer" class="screen-video-container">
                    <video id="remoteScreenVideo" autoplay playsinline style="max-width:100%;"></video>
                    <div style="display:flex; gap:16px; align-items:center;">
                        <span style="color:white; font-weight:700;">üñ•Ô∏è SCREEN SHARE</span>
                        <button id="stopScreenShareBtn" class="stop-share-btn" style="display:none;">‚èπÔ∏è Stop sharing</button>
                    </div>
                </div>

                <!-- Messages log -->
                <div class="messages" id="messageLog">
                    <div class="message system">üü¢ Welcome. Set your name & start chatting. Host can share screen.</div>
                </div>

                <!-- Input row: MESSAGE + DOCUMENT (any file) + SCREEN SHARE (host only) + SEND -->
                <div class="input-row">
                    <input type="text" id="messageInput" placeholder="Type a message..." autocomplete="off" disabled>
                    <!-- üìé DOCUMENT SHARE (replaces old image-only) -->
                    <label for="documentUpload" class="file-label" id="docLabel" title="Share any document">üìé</label>
                    <input type="file" id="documentUpload" accept="*/*" style="display:none;">

                    <!-- üñ•Ô∏è SCREEN SHARE BUTTON (visible only for host) -->
                    <button id="screenShareBtn" class="screen-share-btn" title="Share screen (laptop)" style="display:none;">üñ•Ô∏è</button>

                    <button id="sendBtn" class="btn" disabled>üì§</button>
                </div>

                <!-- status line -->
                <div class="status-bar">
                    <span><span class="dot" id="stateDot"></span> ICE: <span id="iceState">new</span></span>
                    <span><span id="peerCountDisplay">üë• 0</span></span>
                </div>
            </div>
        </div>

        <div style="text-align: center; margin-top: 24px; color: #a8d8e6; font-size: 0.8rem;">
            ‚ö° STUN+TURN ¬∑ any file share ¬∑ screen share (host) ¬∑ mobile oversized UI
        </div>
    </div>

    <script>
        (function(){
            "use strict";

            // ---------- üåç ICE SERVERS (mobile friendly, TURN boosted) ----------
            const ICE_CONFIG = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'turn:openrelayproject.org:3478', username: 'openrelayproject', credential: 'openrelayproject' },
                    { urls: 'turn:turn.anyfirewall.com:443?transport=tcp', username: 'webrtc', credential: 'webrtc' }
                ]
            };

            // ---------- GLOBAL STATE ----------
            let sessionId = null, isHost = false, myPeerId = null, myUsername = 'Guest';
            let peer = null;
            let hostConnections = new Map();   // host -> connected clients
            let clientConn = null;            // client -> host connection

            // Message store + dedup
            let messageStore = [];
            let receivedMsgIds = new Set();
            let hostMessageMap = new Map();   // for ack tracking (host)

            // ---------- SCREEN SHARE (HOST ONLY) ----------
            let screenShareStream = null;
            let screenShareCalls = [];        // store all media connections (as caller)
            let isSharingScreen = false;

            // UI elements
            const preChatSection = document.getElementById('preChatSection');
            const chatInterface = document.getElementById('chatInterface');
            const usernameInput = document.getElementById('usernameInput');
            const messageLog = document.getElementById('messageLog');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const documentUpload = document.getElementById('documentUpload'); // renamed from imageUpload
            const sessionLinkContainer = document.getElementById('sessionLinkContainer');
            const roomLinkDisplay = document.getElementById('roomLinkDisplay');
            const copyRoomLinkBtn = document.getElementById('copyRoomLinkBtn');
            const currentSessionSpan = document.getElementById('currentSessionSpan');
            const connectionStatus = document.getElementById('connectionStatus');
            const iceState = document.getElementById('iceState');
            const stateDot = document.getElementById('stateDot');
            const peerCountDisplay = document.getElementById('peerCountDisplay');
            const screenShareBtn = document.getElementById('screenShareBtn');
            const screenVideoContainer = document.getElementById('screenVideoContainer');
            const remoteScreenVideo = document.getElementById('remoteScreenVideo');
            const stopScreenShareBtn = document.getElementById('stopScreenShareBtn');

            // ---------- helper ----------
            function generateUUID() { return Date.now() + '-' + Math.random().toString(36).substring(2,10); }
            function getUrlParam(p) { return new URLSearchParams(window.location.search).get(p); }
            function buildSessionUrl(s) { const url = new URL(window.location.href); url.searchParams.set('session', s); return url.toString(); }

            // ---------- DISPLAY MESSAGE (now with FILE support) ----------
            function displayMessage(msg, isSelf = false) {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message' + (isSelf ? ' self' : '');
                msgDiv.dataset.msgId = msg.id;

                let senderDisplay = msg.senderName ? msg.senderName : (msg.senderId === myPeerId ? 'You' : 'Peer');
                if (isSelf) senderDisplay = 'You';

                let contentHtml = '';
                if (msg.type === 'file' || msg.type === 'image') {  // support both old image and new file
                    if (msg.fileInfo) {  // new document format
                        const file = msg.fileInfo;
                        const isImage = file.type.startsWith('image/');
                        if (isImage) {
                            contentHtml = `<strong>${senderDisplay}:</strong><br><img src="${msg.content}" alt="image" style="max-width:200px; border-radius:16px;">`;
                        } else {
                            // generic file attachment card
                            contentHtml = `<strong>${senderDisplay}:</strong> 
                                <div class="file-attachment">
                                    <span class="file-icon">üìÑ</span>
                                    <div class="file-info">
                                        <span class="file-name">${file.name || 'document'}</span>
                                        <span class="file-size">${file.size ? (file.size/1024).toFixed(1)+' KB' : ''}</span>
                                    </div>
                                    <a href="${msg.content}" download="${file.name}" class="download-link">‚¨áÔ∏è Download</a>
                                </div>`;
                        }
                    } else {  // legacy image (just in case)
                        contentHtml = `<strong>${senderDisplay}:</strong><br><img src="${msg.content}" style="max-width:180px;">`;
                    }
                } else {
                    contentHtml = `<strong>${senderDisplay}:</strong> ${msg.content}`;
                }
                msgDiv.innerHTML = contentHtml;
                messageLog.appendChild(msgDiv);
                messageLog.scrollTop = messageLog.scrollHeight;
            }

            function addMessageToStore(msg, isSelf = false) {
                if (!msg.id) msg.id = generateUUID();
                if (receivedMsgIds.has(msg.id)) return false;
                receivedMsgIds.add(msg.id);
                messageStore.push(msg);
                displayMessage(msg, isSelf);
                return true;
            }

            // ---------- HOST: process new message (chat/file) ----------
            function hostProcessNewMessage(senderPeerId, senderName, type, content, fileInfo = null, providedMsgId = null) {
                if (!myPeerId) return;
                const msgId = providedMsgId || generateUUID();
                const msg = {
                    id: msgId, senderId: senderPeerId, senderName: senderName || 'unknown',
                    type: type, content: content, timestamp: Date.now()
                };
                if (fileInfo) msg.fileInfo = fileInfo;  // attach file metadata

                const ackSet = new Set([senderPeerId, myPeerId]);
                hostMessageMap.set(msgId, { msg, acks: ackSet });

                addMessageToStore(msg, senderPeerId === myPeerId);
                const broadcastMsg = { type: 'broadcast', msg: msg };
                hostSendMessageToAll(broadcastMsg, senderPeerId);
            }

            function hostSendMessageToAll(data, excludePeerId = null) {
                hostConnections.forEach((conn, pid) => { if (pid !== excludePeerId && conn.open) conn.send(data); });
            }

            // ---------- HOST: screen share ----------
            async function startScreenShare() {
                if (!isHost || !peer) return;
                try {
                    screenShareStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                    isSharingScreen = true;
                    screenVideoContainer.style.display = 'flex';
                    remoteScreenVideo.srcObject = screenShareStream;
                    stopScreenShareBtn.style.display = 'inline-block';

                    // call all currently connected clients
                    hostConnections.forEach((conn, clientPeerId) => {
                        const call = peer.call(clientPeerId, screenShareStream);
                        screenShareCalls.push(call);
                        call.on('close', () => console.log('screen call closed'));
                    });

                    // when new client connects, host will call them (handled in host connection logic)
                } catch (err) {
                    console.error('Screen share error:', err);
                    appendSystemMessage('‚ùå Screen share failed: ' + err.message);
                }
            }

            function stopScreenShare() {
                if (screenShareStream) {
                    screenShareStream.getTracks().forEach(t => t.stop());
                    screenShareStream = null;
                }
                screenShareCalls.forEach(call => call.close());
                screenShareCalls = [];
                isSharingScreen = false;
                screenVideoContainer.style.display = 'none';
                stopScreenShareBtn.style.display = 'none';
                remoteScreenVideo.srcObject = null;
            }

            // ---------- HOST SETUP ----------
            function hostSession() {
                if (!sessionId) { alert('Generate a link first'); return; }
                isHost = true;
                myUsername = usernameInput.value.trim() || 'Host';
                preChatSection.classList.add('hidden');
                chatInterface.classList.remove('hidden');
                currentSessionSpan.innerText = sessionId;
                roomLinkDisplay.innerText = buildSessionUrl(sessionId);

                peer = new Peer(sessionId, { config: ICE_CONFIG, debug: 1 });
                monitorIceState(peer, iceState, stateDot);

                peer.on('open', (id) => {
                    myPeerId = id;
                    connectionStatus.innerText = 'üé§ Hosting';
                    iceState.innerText = 'listening';
                    enableChat(true);
                    appendSystemMessage('Host ready. Share link. You can share screen (üñ•Ô∏è).');
                    screenShareBtn.style.display = 'inline-flex'; // only host sees it
                });

                peer.on('connection', (conn) => {
                    const remotePeerId = conn.peer;
                    hostConnections.set(remotePeerId, conn);
                    updatePeerCountUI();
                    appendSystemMessage(`‚ûï peer joined: ${remotePeerId.substring(0,6)}...`);

                    // if host is already sharing screen, call this new client
                    if (isSharingScreen && screenShareStream) {
                        const call = peer.call(remotePeerId, screenShareStream);
                        screenShareCalls.push(call);
                    }

                    conn.on('data', (data) => handleHostData(remotePeerId, data));
                    conn.on('close', () => {
                        hostRemovePeer(remotePeerId);
                        appendSystemMessage(`‚ûñ peer left: ${remotePeerId.substring(0,6)}...`);
                    });
                    conn.on('error', (err) => console.error('Host conn error:', err));
                    hostSendHistory(conn);
                });

                peer.on('call', (call) => {
                    // Host is only caller for screen share, but if someone else tries to call, answer? We don't support client share ‚Äì just ignore/answer with no stream.
                    call.answer(); 
                    call.on('stream', (remoteStream) => {
                        // if client somehow sends stream, but we don't use.
                    });
                });

                peer.on('error', (err) => {
                    if (err.type === 'unavailable-id') alert('‚ùå Room name taken. Use another.');
                    else appendSystemMessage('Host error: ' + err.type);
                    console.error(err);
                });
            }

            // ---------- CLIENT AUTO JOIN ----------
            function autoJoinClient() {
                isHost = false;
                connectionStatus.innerText = 'üü° connecting...';
                peer = new Peer({ config: ICE_CONFIG, debug: 1 });
                monitorIceState(peer, iceState, stateDot);

                peer.on('open', (id) => {
                    myPeerId = id;
                    connectionStatus.innerText = '‚úÖ connected, joining';
                    const conn = peer.connect(sessionId, { reliable: true });
                    clientConn = conn;
                    setupClientConnection(conn);
                });

                peer.on('call', (call) => {
                    // client receives screen share call from host
                    call.answer(); // no local stream
                    call.on('stream', (remoteStream) => {
                        screenVideoContainer.style.display = 'flex';
                        remoteScreenVideo.srcObject = remoteStream;
                        stopScreenShareBtn.style.display = 'none'; // only host stops
                        appendSystemMessage('üñ•Ô∏è Host is sharing screen');
                    });
                    call.on('close', () => {
                        screenVideoContainer.style.display = 'none';
                        remoteScreenVideo.srcObject = null;
                        appendSystemMessage('üñ•Ô∏è Screen share ended');
                    });
                });

                peer.on('error', (err) => {
                    connectionStatus.innerText = '‚ùå error';
                    appendSystemMessage('Peer error: ' + err.message);
                });
            }

            function setupClientConnection(conn) {
                const timeout = setTimeout(() => {
                    if (!conn.open) appendSystemMessage('‚è≥ Connection slow ‚Äì ICE: ' + iceState.innerText);
                }, 15000);
                conn.on('open', () => {
                    clearTimeout(timeout);
                    connectionStatus.innerText = 'üü¢ connected';
                    iceState.innerText = 'open';
                    stateDot.className = 'dot active';
                    enableChat(true);
                    conn.send({ type: 'setUsername', username: myUsername, peerId: myPeerId });
                    appendSystemMessage('Joined as ' + myUsername);
                });
                conn.on('data', handleClientData);
                conn.on('close', () => { connectionStatus.innerText = '‚ö´ disconnected'; enableChat(false); });
                conn.on('error', (e) => console.error(e));
            }

            function handleClientData(data) {
                if (!data || !data.type) return;
                switch (data.type) {
                    case 'broadcast':
                        if (data.msg && addMessageToStore(data.msg, data.msg.senderId === myPeerId)) {
                            if (clientConn?.open) clientConn.send({ type: 'ack', msgId: data.msg.id });
                        } break;
                    case 'history':
                        if (data.messages) {
                            data.messages.forEach(msg => {
                                if (!receivedMsgIds.has(msg.id)) {
                                    addMessageToStore(msg, msg.senderId === myPeerId);
                                    if (clientConn?.open) clientConn.send({ type: 'ack', msgId: msg.id });
                                }
                            });
                            appendSystemMessage(`üì¶ loaded ${data.messages.length} messages`);
                        } break;
                }
            }

            function handleHostData(peerId, data) {
                switch (data.type) {
                    case 'chat': hostProcessNewMessage(peerId, data.senderName, 'chat', data.content, null, data.msgId); break;
                    case 'image': // fallback for legacy
                    case 'file': 
                        hostProcessNewMessage(peerId, data.senderName, 'file', data.content, data.fileInfo, data.msgId); 
                        break;
                    case 'ack': if (data.msgId) hostProcessAck(peerId, data.msgId); break;
                }
            }

            function hostProcessAck(peerId, msgId) { if (hostMessageMap.has(msgId)) hostMessageMap.get(msgId).acks.add(peerId); }
            function hostRemovePeer(pid) { hostConnections.delete(pid); hostMessageMap.forEach(e => e.acks.delete(pid)); updatePeerCountUI(); }
            function hostSendHistory(conn) { 
                const all = Array.from(hostMessageMap.values()).map(e => e.msg);
                if (all.length) conn.send({ type: 'history', messages: all });
            }

            // ---------- SEND FILE (instead of image) ----------
            function sendFile(file, base64Data) {
                const senderName = usernameInput.value.trim() || 'Anonymous';
                const msgId = generateUUID();
                const fileInfo = {
                    name: file.name,
                    size: file.size,
                    type: file.type || 'application/octet-stream'
                };
                if (isHost) {
                    hostProcessNewMessage(myPeerId, senderName, 'file', base64Data, fileInfo, msgId);
                } else {
                    if (clientConn?.open) {
                        clientConn.send({
                            type: 'file',
                            content: base64Data,
                            senderName: senderName,
                            fileInfo: fileInfo,
                            msgId: msgId
                        });
                        // local echo
                        const tempMsg = { id: msgId, senderId: myPeerId, senderName, type: 'file', content: base64Data, fileInfo, timestamp: Date.now() };
                        addMessageToStore(tempMsg, true);
                    }
                }
            }

            function sendChatMessage(text) {
                if (!text.trim()) return;
                const senderName = usernameInput.value.trim() || 'Anonymous';
                const msgId = generateUUID();
                if (isHost) {
                    hostProcessNewMessage(myPeerId, senderName, 'chat', text, null, msgId);
                } else {
                    if (clientConn?.open) {
                        clientConn.send({ type: 'chat', content: text, senderName, msgId });
                        const tempMsg = { id: msgId, senderId: myPeerId, senderName, type: 'chat', content: text, timestamp: Date.now() };
                        addMessageToStore(tempMsg, true);
                    }
                }
            }

            // ---------- UI ----------
            function enableChat(enable) {
                messageInput.disabled = !enable; sendBtn.disabled = !enable; documentUpload.disabled = !enable;
                if (enable) messageInput.focus();
            }
            function appendSystemMessage(text) {
                const d = document.createElement('div'); d.className = 'message system'; d.innerText = 'üîπ ' + text;
                messageLog.appendChild(d); messageLog.scrollTop = messageLog.scrollHeight;
            }
            function monitorIceState(p, iceEl, dotEl) {
                p.on('iceconnectionstatechange', () => {
                    const s = p.iceConnectionState || 'new'; iceEl.innerText = s;
                    dotEl.className = s === 'connected' || s === 'completed' ? 'dot active' : 'dot';
                });
            }
            function updatePeerCountUI() { if (isHost) peerCountDisplay.innerText = `üë• ${hostConnections.size + 1}`; }

            // ---------- EVENT LISTENERS ----------
            usernameInput.addEventListener('change', e => myUsername = e.target.value.trim() || 'Guest');

            document.getElementById('generateBtn').addEventListener('click', function() {
                let custom = document.getElementById('customSessionId').value.trim();
                let finalId = custom ? custom.replace(/\s+/g, '-').toLowerCase() : ('room-' + Date.now().toString(36) + '-' + Math.random().toString(36).substring(2,6));
                sessionId = finalId;
                const link = buildSessionUrl(finalId);
                document.getElementById('shareableLink').innerText = link;
                document.getElementById('linkOutput').style.display = 'flex';
                currentSessionSpan.innerText = finalId;
                roomLinkDisplay.innerText = link;
            });
            document.getElementById('copyLinkBtn').addEventListener('click', () => navigator.clipboard.writeText(document.getElementById('shareableLink').innerText).then(() => alert('Copied')));
            document.getElementById('hostChatBtn').addEventListener('click', hostSession);
            copyRoomLinkBtn.addEventListener('click', () => navigator.clipboard.writeText(roomLinkDisplay.innerText).then(() => alert('Room link copied')));

            // üìé DOCUMENT SHARE (replaces image)
            documentUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => { sendFile(file, ev.target.result); documentUpload.value = ''; };
                reader.readAsDataURL(file);
            });

            // screen share button (host only)
            screenShareBtn.addEventListener('click', function() {
                if (isHost && !isSharingScreen) startScreenShare();
            });
            stopScreenShareBtn.addEventListener('click', function() { stopScreenShare(); });

            sendBtn.addEventListener('click', () => { sendChatMessage(messageInput.value); messageInput.value = ''; });
            messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !sendBtn.disabled) { sendChatMessage(messageInput.value); messageInput.value = ''; } });

            // URL init
            function initFromUrl() {
                const urlSession = getUrlParam('session');
                if (urlSession) {
                    sessionId = urlSession;
                    preChatSection.classList.add('hidden');
                    chatInterface.classList.remove('hidden');
                    currentSessionSpan.innerText = sessionId;
                    roomLinkDisplay.innerText = buildSessionUrl(sessionId);
                    usernameInput.value = 'Guest_' + Math.random().toString(36).substring(2,6);
                    myUsername = usernameInput.value;
                    autoJoinClient();
                } else {
                    preChatSection.classList.remove('hidden');
                    chatInterface.classList.add('hidden');
                }
            }
            initFromUrl();
            setInterval(() => { if (isHost) updatePeerCountUI(); }, 1000);
        })();
    </script>
</body>
</html>
