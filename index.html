<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>üì° GroupChat ¬∑ STUN/TURN ¬∑ image + ack sync (mobile‚Äëfixed)</title>
    <!-- PeerJS for signaling & multi-peer -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        /* your existing CSS ‚Äì unchanged ‚Äì I keep it exactly as you had it */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: radial-gradient(circle at 10% 30%, #d4e0ec, #b6c8d9); min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 12px; }
        .app { max-width: 1000px; width: 100%; background: rgba(255,255,255,0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 36px; box-shadow: 0 20px 40px rgba(0,20,40,0.25); padding: 24px 20px; border: 1px solid rgba(255,255,255,0.5); }
        .header { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        h1 { font-size: 1.8rem; font-weight: 700; color: #0b2d4b; letter-spacing: -0.5px; display: flex; align-items: center; gap: 8px; }
        .ice-badge { background: #1f4a6b; color: white; padding: 6px 16px; border-radius: 50px; font-size: 0.75rem; font-weight: 600; white-space: nowrap; }
        .username-panel { background: white; border-radius: 60px; padding: 10px 18px; margin-bottom: 20px; display: flex; flex-wrap: wrap; align-items: center; gap: 12px; border: 1px solid #b6d0e2; box-shadow: inset 0 1px 4px rgba(0,0,0,0.02); }
        .username-panel label { font-weight: 600; color: #1f4973; font-size: 0.95rem; }
        #usernameInput { flex: 1; min-width: 180px; padding: 12px 18px; border: 1.5px solid #c9daea; border-radius: 50px; font-size: 1rem; background: #f9fcff; outline: none; transition: 0.2s; }
        #usernameInput:focus { border-color: #2a6c9e; box-shadow: 0 0 0 3px rgba(42,108,158,0.15); }
        .section { background: rgba(255,255,255,0.5); border-radius: 28px; padding: 22px 18px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.7); }
        .flex-row { display: flex; flex-wrap: wrap; align-items: center; gap: 14px; }
        .btn { background: #1e3f5f; border: none; color: white; padding: 12px 24px; border-radius: 50px; font-weight: 600; font-size: 0.95rem; display: inline-flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; transition: 0.2s; border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 6px 12px rgba(0,30,60,0.1); flex: 0 0 auto; }
        .btn:hover { background: #2d5b7c; transform: scale(0.97); }
        .btn:disabled { opacity: 0.45; pointer-events: none; }
        .btn-outline { background: transparent; border: 2px solid #1e3f5f; color: #1e3f5f; box-shadow: none; }
        .link-box { background: #e2ebf3; padding: 14px 18px; border-radius: 40px; word-break: break-all; font-size: 0.9rem; border: 1px solid #a0bedb; display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; margin-top: 12px; }
        .chat-container { background: #f2f7fd; border-radius: 28px; padding: 18px; margin-top: 8px; border: 1px solid #ccdcec; }
        .messages { background: white; border-radius: 24px; padding: 18px; height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px; border: 1px solid #d6e2ec; }
        .message { background: #f0f6fc; padding: 12px 18px; border-radius: 22px; max-width: 90%; word-break: break-word; align-self: flex-start; border: 1px solid #dbe2ea; font-size: 0.95rem; line-height: 1.4; }
        .message.self { background: #1e3b5a; color: white; align-self: flex-end; border: none; }
        .message.system { background: transparent; color: #3c627c; align-self: center; font-size: 0.8rem; border: 1px dashed #8da9c2; max-width: 95%; }
        .message img { max-width: 180px; max-height: 180px; border-radius: 16px; display: block; margin-top: 6px; border: 1px solid #ccc; }
        .input-row { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
        #messageInput { flex: 1; min-width: 180px; padding: 14px 20px; border: 2px solid #c6d9e8; border-radius: 50px; font-size: 1rem; background: white; outline: none; }
        #messageInput:focus { border-color: #2b6990; }
        .file-label { background: #edf4fa; padding: 12px 18px; border-radius: 50px; font-size: 1.1rem; border: 1px solid #acc3d9; cursor: pointer; color: #1e3f5f; display: inline-flex; align-items: center; gap: 6px; }
        #imageUpload { display: none; }
        .status-bar { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between; margin-top: 12px; font-size: 0.8rem; color: #1e4e6c; background: rgba(255,255,255,0.7); padding: 10px 18px; border-radius: 50px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #9eb7c9; display: inline-block; margin-right: 6px; }
        .dot.active { background: #28a745; box-shadow: 0 0 12px #28a745; }
        .hidden { display: none !important; }
        .peer-count { background: #1f3f5f; color: white; padding: 4px 14px; border-radius: 50px; font-size: 0.75rem; }
        @media (max-width: 600px) { .app { padding: 16px; } h1 { font-size: 1.5rem; } .btn { padding: 10px 18px; } }
    </style>
</head>
<body>
    <div class="app" id="app">

        <!-- HEADER with STUN/TURN info -->
        <div class="header">
            <h1>üë• ShareChat <span style="font-size: 0.8rem; background: #cde1f0; padding: 4px 12px; border-radius: 40px; color: #0d3a5a;">ack sync</span></h1>
            <span class="ice-badge">‚ö° TURN‚Äëboosted for mobile</span>
        </div>

        <!-- GLOBAL USERNAME (always visible) -->
        <div class="username-panel">
            <label>üë§ Name</label>
            <input type="text" id="usernameInput" placeholder="Your nickname" value="Guest" autocomplete="off">
        </div>

        <!-- ========== PRE-CHAT: SESSION CREATION (only if no session in URL) ========= -->
        <div id="preChatSection">
            <div id="generatorView" class="section">
                <div style="margin-bottom: 16px; font-weight: 600; color: #1f4973;">üöÄ Start new room</div>
                <div class="flex-row">
                    <input type="text" id="customSessionId" class="flex-row" placeholder="room name (optional)" style="flex:1; padding: 14px 20px; border-radius: 60px; border: 1.5px solid #b8d0df; background: white; font-size:1rem;">
                    <button id="generateBtn" class="btn">üîó Generate link</button>
                </div>
                <!-- generated link + host -->
                <div id="linkOutput" style="display: none;" class="link-box">
                    <span id="shareableLink" style="font-weight: 500; word-break: break-all;"></span>
                    <button id="copyLinkBtn" style="background: transparent; border: none; font-size: 1.4rem; cursor: pointer; padding: 6px;" title="copy">üìã</button>
                </div>
                <div style="margin-top: 20px;">
                    <button id="hostChatBtn" class="btn" style="background: #225a7a; padding: 14px 32px;">üé§ Host this room</button>
                    <span style="margin-left: 12px; color: #326480; font-size: 0.9rem;">(you'll be the hub)</span>
                </div>
            </div>
        </div>

        <!-- ========== CHAT INTERFACE (hidden until host/client starts) ========= -->
        <div id="chatInterface" class="hidden">
            <!-- room info: session link always shown for host & clients -->
            <div id="sessionLinkContainer" style="background: #e4edf5; border-radius: 40px; padding: 12px 20px; margin-bottom: 16px; display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                <span style="font-weight: 600;">üîó room:</span>
                <span id="roomLinkDisplay" style="word-break: break-all; font-size: 0.8rem; background: white; padding: 6px 16px; border-radius: 50px;"></span>
                <button id="copyRoomLinkBtn" style="background: white; border: 1px solid #5f8da0; padding: 6px 16px; border-radius: 40px; font-size: 0.8rem;">üìã copy</button>
            </div>

            <!-- chat area -->
            <div class="chat-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <span id="roomNameBadge" style="background: #cedce8; padding: 6px 18px; border-radius: 50px; font-size: 0.8rem;">üìå session: <span id="currentSessionSpan">-</span></span>
                    <span id="connectionStatus" class="peer-count">‚öôÔ∏è connecting</span>
                </div>
                <!-- Messages log -->
                <div class="messages" id="messageLog">
                    <div class="message system">üü¢ Welcome. Set your name above and start chatting.</div>
                </div>
                <!-- Input + image -->
                <div class="input-row">
                    <input type="text" id="messageInput" placeholder="Type a message..." autocomplete="off" disabled>
                    <button id="sendBtn" class="btn" disabled>üì§</button>
                    <label for="imageUpload" class="file-label" id="imageLabel">üñºÔ∏è</label>
                    <input type="file" id="imageUpload" accept="image/*" capture="environment">
                </div>
                <!-- Status line with ice & peer count -->
                <div class="status-bar">
                    <span><span class="dot" id="stateDot"></span> ICE: <span id="iceState">new</span></span>
                    <span><span id="peerCountDisplay">üë• 0</span></span>
                </div>
            </div>
        </div>

        <!-- footer -->
        <div style="text-align: center; margin-top: 20px; color: #3f617c; font-size: 0.75rem;">
            ‚ö° Public STUN/TURN (mobile‚Äëoptimized) ¬∑ PeerJS signaling ¬∑ messages auto-synced to new members
        </div>
    </div>

    <script>
        (function(){
            "use strict";

            // ---------- üåç RELIABLE ICE SERVERS (mobile friendly) ----------
            const ICE_CONFIG = {
                iceServers: [
                    // Google STUN ‚Äì always good
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },

                    // openrelayproject ‚Äì both UDP and TCP
                    {
                        urls: 'turn:openrelayproject.org:3478',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelayproject.org:3478?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },

                    // numb.viagenie.ca (still active, public test account)
                    {
                        urls: 'turn:numb.viagenie.ca:3478',
                        username: 'letmein',
                        credential: 'letmein'
                    },
                    {
                        urls: 'turn:numb.viagenie.ca:3478?transport=tcp',
                        username: 'letmein',
                        credential: 'letmein'
                    },

                    // fallback TURN over TCP/443 (often allowed on cellular)
                    {
                        urls: 'turn:turn.anyfirewall.com:443?transport=tcp',
                        username: 'webrtc',
                        credential: 'webrtc'
                    }
                ],
                // Optional: force TURN if direct connection fails (uncomment if needed)
                // iceTransportPolicy: 'relay'
            };

            // ---------- GLOBAL STATE ----------
            let sessionId = null;
            let isHost = false;
            let myPeerId = null;
            let myUsername = 'Guest';

            let peer = null;
            let hostConnections = new Map();
            let clientConn = null;

            let messageStore = [];
            let receivedMsgIds = new Set();

            let hostMessageMap = new Map();

            // UI elements
            const generatorView = document.getElementById('generatorView');
            const preChatSection = document.getElementById('preChatSection');
            const chatInterface = document.getElementById('chatInterface');
            const usernameInput = document.getElementById('usernameInput');
            const messageLog = document.getElementById('messageLog');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const imageUpload = document.getElementById('imageUpload');
            const sessionLinkContainer = document.getElementById('sessionLinkContainer');
            const roomLinkDisplay = document.getElementById('roomLinkDisplay');
            const copyRoomLinkBtn = document.getElementById('copyRoomLinkBtn');
            const currentSessionSpan = document.getElementById('currentSessionSpan');
            const connectionStatus = document.getElementById('connectionStatus');
            const iceState = document.getElementById('iceState');
            const stateDot = document.getElementById('stateDot');
            const peerCountDisplay = document.getElementById('peerCountDisplay');

            // ---------- Helper functions ----------
            function generateUUID() {
                return Date.now() + '-' + Math.random().toString(36).substring(2, 10);
            }

            function getUrlParam(param) {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get(param);
            }

            function buildSessionUrl(session) {
                const url = new URL(window.location.href);
                url.searchParams.set('session', session);
                return url.toString();
            }

            function displayMessage(msg, isSelf = false) {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message' + (isSelf ? ' self' : '');
                msgDiv.dataset.msgId = msg.id;

                let senderDisplay = msg.senderName ? msg.senderName : (msg.senderId === myPeerId ? 'You' : 'Peer');
                if (isSelf) senderDisplay = 'You';

                let contentHtml = '';
                if (msg.type === 'image') {
                    contentHtml = `<strong>${senderDisplay}:</strong><br><img src="${msg.content}" alt="shared image" style="max-width:180px;">`;
                } else {
                    contentHtml = `<strong>${senderDisplay}:</strong> ${msg.content}`;
                }
                msgDiv.innerHTML = contentHtml;
                messageLog.appendChild(msgDiv);
                messageLog.scrollTop = messageLog.scrollHeight;
            }

            function addMessageToStore(msg, isSelf = false) {
                if (!msg.id) msg.id = generateUUID();
                if (receivedMsgIds.has(msg.id)) return false;
                receivedMsgIds.add(msg.id);
                messageStore.push(msg);
                displayMessage(msg, isSelf);
                return true;
            }

            function updatePeerCountUI() {
                if (isHost) {
                    peerCountDisplay.innerText = `üë• ${hostConnections.size + 1}`;
                } else {
                    peerCountDisplay.innerText = `üë• 2+`;
                }
            }

            // ---------- HOST SPECIFIC ----------
            function hostSendMessageToAll(data, excludePeerId = null) {
                hostConnections.forEach((conn, peerId) => {
                    if (peerId !== excludePeerId && conn.open) {
                        conn.send(data);
                    }
                });
            }

            function hostProcessNewMessage(senderPeerId, senderName, type, content, providedMsgId = null) {
                if (!myPeerId) {
                    console.warn('hostProcessNewMessage: myPeerId not ready');
                    appendSystemMessage('‚ö†Ô∏è Cannot send: host not fully initialized');
                    return;
                }
                const msgId = providedMsgId || generateUUID();
                const timestamp = Date.now();
                const msg = {
                    id: msgId,
                    senderId: senderPeerId,
                    senderName: senderName || 'unknown',
                    type: type,
                    content: content,
                    timestamp: timestamp
                };
                const ackSet = new Set();
                ackSet.add(senderPeerId);
                ackSet.add(myPeerId);
                hostMessageMap.set(msgId, { msg, acks: ackSet });

                if (senderPeerId !== myPeerId) {
                    addMessageToStore(msg, false);
                } else {
                    addMessageToStore(msg, true);
                }

                const broadcastMsg = { type: 'broadcast', msg: msg };
                hostSendMessageToAll(broadcastMsg, senderPeerId);
            }

            function hostSendHistory(conn, targetPeerId) {
                const allMessages = Array.from(hostMessageMap.values()).map(item => item.msg);
                if (allMessages.length === 0) return;
                const historyPacket = { type: 'history', messages: allMessages };
                conn.send(historyPacket);
            }

            function hostProcessAck(peerId, msgId) {
                if (hostMessageMap.has(msgId)) {
                    const entry = hostMessageMap.get(msgId);
                    entry.acks.add(peerId);
                }
            }

            function hostRemovePeer(peerId) {
                hostConnections.delete(peerId);
                hostMessageMap.forEach((entry, msgId) => {
                    entry.acks.delete(peerId);
                });
                updatePeerCountUI();
            }

            // ---------- CLIENT & HOST ICE STATE MONITOR (crucial for mobile!) ----------
            function monitorIceState(peerInstance, uiIceElement, uiDotElement) {
                if (!peerInstance) return;
                peerInstance.on('iceconnectionstatechange', () => {
                    const state = peerInstance.iceConnectionState || 'new';
                    uiIceElement.innerText = state;
                    if (state === 'connected' || state === 'completed') {
                        uiDotElement.className = 'dot active';
                    } else {
                        uiDotElement.className = 'dot';
                    }
                    // helpful for debugging
                    console.log('ICE state:', state);
                });
            }

            // ---------- INIT & URL DETECTION ----------
            function initFromUrl() {
                const urlSession = getUrlParam('session');
                if (urlSession) {
                    sessionId = urlSession;
                    preChatSection.classList.add('hidden');
                    chatInterface.classList.remove('hidden');
                    currentSessionSpan.innerText = sessionId;
                    const fullLink = buildSessionUrl(sessionId);
                    roomLinkDisplay.innerText = fullLink;
                    const defaultName = 'Guest_' + Math.random().toString(36).substring(2, 6);
                    usernameInput.value = defaultName;
                    myUsername = defaultName;
                    autoJoinClient();
                } else {
                    preChatSection.classList.remove('hidden');
                    chatInterface.classList.add('hidden');
                }
            }

            // AUTO CLIENT JOIN (with ICE monitoring & timeout)
            function autoJoinClient() {
                isHost = false;
                connectionStatus.innerText = 'üü° connecting...';
                peer = new Peer({
                    config: ICE_CONFIG,
                    debug: 1
                });

                // üëâ client ICE state monitoring
                monitorIceState(peer, iceState, stateDot);

                peer.on('open', (id) => {
                    myPeerId = id;
                    connectionStatus.innerText = '‚úÖ connected, joining room';
                    const conn = peer.connect(sessionId, { reliable: true });
                    clientConn = conn;
                    setupClientConnection(conn);
                });

                peer.on('error', (err) => {
                    connectionStatus.innerText = '‚ùå error';
                    appendSystemMessage('Peer error: ' + err.type + ' - ' + (err.message || ''));
                    console.error('Peer error:', err);
                });
            }

            function setupClientConnection(conn) {
                // timeout: if connection not opened in 15 sec, show warning
                const connTimeout = setTimeout(() => {
                    if (!conn.open) {
                        appendSystemMessage('‚è≥ Connection is taking longer than expected ‚Äì ICE state: ' + iceState.innerText);
                    }
                }, 15000);

                conn.on('open', () => {
                    clearTimeout(connTimeout);
                    connectionStatus.innerText = 'üü¢ connected';
                    iceState.innerText = 'open';   // fallback ‚Äì real ICE state is shown via monitor
                    stateDot.className = 'dot active';
                    enableChat(true);
                    conn.send({ type: 'setUsername', username: myUsername, peerId: myPeerId });
                    appendSystemMessage('Joined room as ' + myUsername);
                });

                conn.on('data', (data) => {
                    handleClientData(data);
                });

                conn.on('close', () => {
                    connectionStatus.innerText = '‚ö´ disconnected';
                    enableChat(false);
                });

                conn.on('error', (err) => {
                    console.error('DataConnection error:', err);
                    appendSystemMessage('Connection error: ' + (err.message || err.type || 'unknown'));
                });
            }

            function handleClientData(data) {
                if (!data || !data.type) return;
                switch (data.type) {
                    case 'broadcast':
                        if (data.msg) {
                            const isSelf = (data.msg.senderId === myPeerId);
                            if (addMessageToStore(data.msg, isSelf)) {
                                if (clientConn && clientConn.open) {
                                    clientConn.send({ type: 'ack', msgId: data.msg.id });
                                }
                            }
                        }
                        break;
                    case 'history':
                        if (data.messages && Array.isArray(data.messages)) {
                            data.messages.forEach(msg => {
                                if (!receivedMsgIds.has(msg.id)) {
                                    addMessageToStore(msg, msg.senderId === myPeerId);
                                    if (clientConn && clientConn.open) {
                                        clientConn.send({ type: 'ack', msgId: msg.id });
                                    }
                                }
                            });
                            appendSystemMessage(`üì¶ history loaded (${data.messages.length} messages)`);
                        }
                        break;
                    case 'delete':
                        // auto-delete disabled ‚Äì ignore
                        break;
                    default: break;
                }
            }

            // ---------- HOST SETUP ----------
            function hostSession() {
                if (!sessionId) {
                    alert('Generate a session link first');
                    return;
                }
                isHost = true;
                myUsername = usernameInput.value.trim() || 'Host';
                preChatSection.classList.add('hidden');
                chatInterface.classList.remove('hidden');
                currentSessionSpan.innerText = sessionId;
                const fullLink = buildSessionUrl(sessionId);
                roomLinkDisplay.innerText = fullLink;

                peer = new Peer(sessionId, {
                    config: ICE_CONFIG,
                    debug: 1
                });

                // üëâ host ICE state monitoring
                monitorIceState(peer, iceState, stateDot);

                peer.on('open', (id) => {
                    myPeerId = id;
                    connectionStatus.innerText = 'üé§ Hosting';
                    iceState.innerText = 'listening';
                    enableChat(true);
                    appendSystemMessage('Host ready. Share link and wait for peers.');
                });

                peer.on('connection', (conn) => {
                    const remotePeerId = conn.peer;
                    hostConnections.set(remotePeerId, conn);
                    updatePeerCountUI();
                    appendSystemMessage(`‚ûï peer joined: ${remotePeerId.substring(0,6)}...`);

                    // ICE state might already be updated via monitor, but we set a visual hint
                    iceState.innerText = 'connected';
                    stateDot.className = 'dot active';

                    conn.on('data', (data) => {
                        handleHostData(remotePeerId, data);
                    });
                    conn.on('close', () => {
                        hostRemovePeer(remotePeerId);
                        appendSystemMessage(`‚ûñ peer left: ${remotePeerId.substring(0,6)}...`);
                        if (hostConnections.size === 0) {
                            iceState.innerText = 'listening';
                            stateDot.className = 'dot';
                        }
                    });
                    conn.on('error', (err) => {
                        console.error('Host connection error:', err);
                        appendSystemMessage(`Peer connection error: ${err.message || err.type}`);
                    });

                    hostSendHistory(conn, remotePeerId);
                });

                peer.on('error', (err) => {
                    if (err.type === 'unavailable-id') {
                        alert('‚ùå This room name is already in use. Please generate a different one.');
                    } else {
                        appendSystemMessage('Host error: ' + err.type + ' - ' + (err.message || ''));
                    }
                    console.error('Peer host error:', err);
                });
            }

            function handleHostData(peerId, data) {
                if (!data.type) return;
                switch (data.type) {
                    case 'setUsername':
                        // store mapping if needed (optional)
                        break;
                    case 'chat':
                        hostProcessNewMessage(peerId, data.senderName || 'Peer', 'chat', data.content, data.msgId);
                        break;
                    case 'image':
                        hostProcessNewMessage(peerId, data.senderName || 'Peer', 'image', data.content, data.msgId);
                        break;
                    case 'ack':
                        if (data.msgId) hostProcessAck(peerId, data.msgId);
                        break;
                }
            }

            // ---------- SEND MESSAGE (client or host) ----------
            function sendChatMessage(text) {
                if (!text.trim()) return;
                if (isHost && !myPeerId) {
                    appendSystemMessage('‚ö†Ô∏è Host not ready yet, please wait...');
                    return;
                }
                const senderName = usernameInput.value.trim() || 'Anonymous';
                const msgId = generateUUID();
                if (isHost) {
                    hostProcessNewMessage(myPeerId, senderName, 'chat', text, msgId);
                } else {
                    if (clientConn && clientConn.open) {
                        clientConn.send({
                            type: 'chat',
                            content: text,
                            senderName: senderName,
                            msgId: msgId
                        });
                        const tempMsg = {
                            id: msgId,
                            senderId: myPeerId,
                            senderName: senderName,
                            type: 'chat',
                            content: text,
                            timestamp: Date.now()
                        };
                        addMessageToStore(tempMsg, true);
                    }
                }
            }

            function sendImage(base64Data) {
                const senderName = usernameInput.value.trim() || 'Anonymous';
                const msgId = generateUUID();
                if (isHost) {
                    if (!myPeerId) {
                        appendSystemMessage('‚ö†Ô∏è Host not ready yet, please wait...');
                        return;
                    }
                    hostProcessNewMessage(myPeerId, senderName, 'image', base64Data, msgId);
                } else {
                    if (clientConn && clientConn.open) {
                        clientConn.send({
                            type: 'image',
                            content: base64Data,
                            senderName: senderName,
                            msgId: msgId
                        });
                        const tempMsg = {
                            id: msgId,
                            senderId: myPeerId,
                            senderName: senderName,
                            type: 'image',
                            content: base64Data,
                            timestamp: Date.now()
                        };
                        addMessageToStore(tempMsg, true);
                    }
                }
            }

            // ---------- UI helpers ----------
            function enableChat(enable) {
                messageInput.disabled = !enable;
                sendBtn.disabled = !enable;
                imageUpload.disabled = !enable;
                if (enable) messageInput.focus();
            }

            function appendSystemMessage(text) {
                const sysDiv = document.createElement('div');
                sysDiv.className = 'message system';
                sysDiv.innerText = 'üîπ ' + text;
                messageLog.appendChild(sysDiv);
                messageLog.scrollTop = messageLog.scrollHeight;
            }

            // ---------- EVENT LISTENERS ----------
            usernameInput.addEventListener('change', function(e) {
                myUsername = e.target.value.trim() || 'Guest';
            });

            document.getElementById('generateBtn').addEventListener('click', function() {
                let custom = document.getElementById('customSessionId').value.trim();
                let finalId = custom ? custom.replace(/\s+/g, '-').toLowerCase() : ('room-' + Date.now().toString(36) + '-' + Math.random().toString(36).substring(2,6));
                sessionId = finalId;
                const link = buildSessionUrl(finalId);
                document.getElementById('shareableLink').innerText = link;
                document.getElementById('linkOutput').style.display = 'flex';
                currentSessionSpan.innerText = finalId;
                roomLinkDisplay.innerText = link;
            });

            document.getElementById('copyLinkBtn').addEventListener('click', function() {
                const link = document.getElementById('shareableLink').innerText;
                navigator.clipboard.writeText(link).then(() => alert('Link copied')).catch(() => alert('Press Ctrl+C'));
            });

            document.getElementById('hostChatBtn').addEventListener('click', hostSession);

            copyRoomLinkBtn.addEventListener('click', function() {
                navigator.clipboard.writeText(roomLinkDisplay.innerText).then(() => alert('Room link copied')).catch(() => alert('Copy manually'));
            });

            sendBtn.addEventListener('click', function() {
                sendChatMessage(messageInput.value);
                messageInput.value = '';
            });

            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !sendBtn.disabled) {
                    sendChatMessage(messageInput.value);
                    messageInput.value = '';
                }
            });

            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    const base64 = ev.target.result;
                    sendImage(base64);
                    imageUpload.value = '';
                };
                reader.readAsDataURL(file);
            });

            // Start
            initFromUrl();

            setInterval(() => {
                if (isHost) updatePeerCountUI();
            }, 1000);
        })();
    </script>
</body>
</html>
